(function(app) {

    /**
     * Base View class. Use {@link View.ViewManager} to create instances of views.
     *
     * @class View.View
     * @alias SUGAR.App.view.View
     */
    app.view.View = app.view.Component.extend({

        className: "view",

        /**
         * TODO: add docs (describe options parameter, see Component class for an example).
         * @constructor
         * @param options
         */
        initialize: function(options) {
            app.view.Component.prototype.initialize.call(this, options);

            // TODO: Do we need this?
            //_.bindAll(this);

            // temp variables used to check metadata values for listeners
            var tmpModule = options.module,
                tmpLayout = app.metadata.getCurrentLayout(),
                tmpView   = options.name;

            // if we have all three pieces of data, check and see if there are listeners in the metadata
            if( tmpModule && tmpLayout && tmpView )  {
                this.listeners = app.metadata.getListeners( tmpModule , tmpLayout, tmpView );

                // if there were listeners outlined in metadata, parse through them and add event listeners
                if( this.listeners != null )  {
                    this.parseEventListeners();
                }
            }

            /**
             * Name of the view (required).
             * @cfg {String}
             */
            this.name = options.name;

            /**
             * Id of the View. Autogenerated if not specified.
             * @property {String}
             * @member {View.View}
             */
            this.id = options.id || this.getID();

            /**
             * Template to render (optional).
             * @cfg {Function}
             */
            this.template = app.template.getView(this.name, this.module) ||
                            app.template.getView(this.name);

            /**
             * Dictionary of field widgets.
             *
             * - keys: field IDs (sfuuid)
             * - value: instances of `app.view.Field` class
             */
            this.fields = {};

            /**
             * CSS class.
             *
             * CSS class which is specified as the `className` parameter
             * in `params` hash for {@link View.ViewManager#createView} method.
             *
             * By default the view is rendered as `div` element with CSS class `"view <viewName>"`.
             * @cfg {String} className
             */
            this.$el.addClass(options.className || this.name || "");

            /**
             * A template to use for view fields if a field does not have a template defined for its parent view.
             * Defaults to `"default"`.
             *
             * For example, if you have a subview and don't want to define subview template for all field types,
             * you may choose to use existing templates like `detail` if your subview is in fact a detail view.
             *
             * @property {String}
             */
            this.fallbackFieldTemplate = "default";
        },

        /**
         * Renders a view for the given context.
         *
         * This method uses this view's {@link View.View#template} property to render itself.
         * @param ctx Template context.
         * @protected
         */
        _renderWithContext: function(ctx) {
            if (this.template) {
                try {
                    this.$el.html(this.template(ctx));
                } catch (e) {
                    app.logger.error("Failed to render '" + this.name + "' view.\n" + e);
                    // TODO: trigger app event to render an error message
                }
            }
        },

        /**
         * Renders the view onto the page.
         *
         * This method uses this view as the context for the view's Handlebars {@link View.View#template}.
         * You can override this method if you have custom rendering logic and don't use Handlebars templating
         * or if you need to pass different context object for the template.
         *
         * Example:
         * <pre><code>
         * app.view.views.CustomView = app.view.View.extend({
         *    _render: function() {
         *      var customCtx = {
         *         // Your custom context for this view template
         *      };
         *      this._renderWithContext(customCtx);
         *    }
         * });
         *
         * // Or totally different logic that doesn't use this.template
         * app.view.views.AnotherCustomView = app.view.View.extend({
         *    _render: function() {
         *       // Never do this :)
         *       return "&lt;div&gt;Hello, world!&lt;/div&gt;";
         *    }
         * });
         *
         *
         * </code></pre>
         * @protected
         */
        _render: function() {
            this._renderWithContext(this);
        },

        /**
         * Renders a field.
         *
         * This method sets field's view element and invokes render on the given field.
         * @param {View.Field} field The field to render
         * @protected
         */
        _renderField: function(field) {
            field.setElement(this.$("span[sfuuid='" + field.sfId + "']"));
            try {
                field.render();
            } catch (e) {
                app.logger.error("Failed to render field '" + field.name + "' on '" + this.name + "' view.\n" + e);
                // TODO: trigger app event to render an error message
            }
        },

        /**
         * Renders the view onto the page.
         * See Backbone.View documentation for details.
         * @return {Object} Reference to this view.
         */
        render: function() {
            if (app.acl.hasAccess(this.name, this.module)) {
                this._render();
                // Render will create a placeholder for sugar fields. we now need to populate those fields
                _.each(this.fields, function(field) {
                    this._renderField(field);
                }, this);
            } else {
                app.logger.info("Current user does not have access to this module view.");
                //TODO trigger app event to notify user about no access or render a "no access" template
            }

            return this;
        },

        /**
         * Extracts the fields from the metadata for directly related views/panels
         * TODO: Possibly refactor
         * @return {Array} List of fields used on this view
         */
        getFields: function() {
            var fields = [];
            var module = this.context.get('module');
            var fieldMetadata;

            if (this.meta && this.meta.panels) {
                _.each(this.meta.panels, function(panel) {
                    fields = fields.concat(_.pluck(panel.fields, 'name'));
                });
            }

            var result = _.filter(_.uniq(fields), function(value) {
                return value;
            });

            // we need to find the relates and add the actual id fields
            fieldMetadata = app.metadata.getModule(module, 'fields');
            if (fieldMetadata) {
                _.each(result, function(entry) {
                    if (fieldMetadata[entry] && fieldMetadata[entry].type == 'relate') {
                        result.push(fieldMetadata[entry].id_name);
                    }
                });
            }


            return result;
        },

        /**
         * Returns the html id of this view's el. Will create one if one doesn't exist.
         * @return {String} id of this view.
         */
        getID: function() {
            return (this.id || this.module || "") + "_" + this.name;
        },


        /**
         * Binds data changes to the model to trigger an initial view to render
         */
        bindDataChange: function() {
            if (this.collection) {
                this.collection.on("reset", this.render, this);
            }
        },

        /**
         * Parses through this.listeners and applies event listeners and handlers as specified in metadata
         */
        parseEventListeners: function() {
            // check again that listeners are not null before proceeding
            if( this.listeners != null )  {
                var listeners = this.listeners;
                for( var i in listeners )  {
                    app.events.on( i , this[listeners[i]], this);
                }
            }
        }


    });


})(SUGAR.App);
