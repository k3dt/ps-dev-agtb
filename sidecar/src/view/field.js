(function(app) {

    /**
     * SugarField widget. A field widget is a low level field widget. Some examples of fields are
     * text boxes, date pickers, drop down menus.
     *
     * ##Creating a SugarField
     * SugarCRM allows for customized "fields" which are visual representations of a type of data (e.g. url would
     * be displayed as a hyperlink).
     *
     * ###Anatomy of a SugarField
     * Field files reside in the **`sugarcrm/clients/base/fields/{field_type}`** folder.
     *
     * Inside the {field_type} directory is a set of files that define templates for different views and field controller.
     * A typical directory structure will look like the following:
     * <pre>
     * clients
     * |- base
     *    |- bool
     *       |- bool.js
     *       |- detail.hbt
     *       |- edit.hbt
     *       |- list.hbt
     *    |- int
     *       ...
     *    |- text
     *       ...
     * |- portal
     *    |- portal specific overrides
     * |- mobile
     *    |- mobile specific overrides
     * </pre>
     * **`[sugarFieldType].js`** files are optional.
     * Sometimes a SugarField needs to do more than just display a simple input element, other times input elements
     * need additional data such as drop down menu choices. To support advanced functionality, just add your additional
     * controller logic to **`[sugarFieldType].js`** javascript file where sugarFieldType is the type of the SugarField.
     * Example for `bool.js` controller:
     * <pre><code>
     * ({
     *    events: {
     *         handler: function() {
     *             // Actions
     *         }
     *    },
     *
     *    initialize: function(options) {
     *       app.view.Field.prototype.initialize(options);
     *       // Your constructor code here follows...
     *    },
     *
     *    unformat: function(value) {
     *        value = this.el.children[0].children[1].checked ? "1" : "0";
     *        return value;
     *    },
     *    format: function(value) {
     *        value = (value == "1") ? true : false;
     *        return value;
     *    }
     * })
     * </code></pre>
     *
     * **`.hbt`** files contain your templates corresponding to the type of {@link View.View} the field is to be displayed on.
     * Sugar uses Handlebars.js as its client side template of choice. At this time no other templating engines are
     * supported. Sample:
     * <pre><code>
     * &lt;span name="{{name}}"&gt;{{value}}&lt;/span&gt;
     * </code></pre>
     *
     * These files will be used by the metadata manager to generate metadata for your SugarFields and pass them onto the
     * Sugar JavaScript client.
     *
     * </pre></code>
     *
     * ####SugarField Template Values
     * TODO:
     *
     *
     * @class View.Field
     */
    app.view.Field = app.view.Component.extend({

        /**
         * HTML tag of the field.
         * @property {String}
         */
        fieldTag: "input",

        /**
         * TODO: add docs (describe options, see Component class for details)
         * @param options
         */
        initialize: function(options) {
            app.view.Component.prototype.initialize.call(this, options);

            /**
             * ID of the field (autogenerated).
             * @property {Number}
             * @member View.Field
             */
            this.sfId = options.sfId;

            /**
             * Reference to the view this field is attached to.
             * @property {View.View}
             * @member View.Field
             */
            this.view = options.view;

            /**
             * Field name.
             * @property {String}
             * @member View.Field
             */
            this.name = this.options.def.name;

            /**
             * Widget type (text, bool, int, etc.).
             * @property {String}
             * @member View.Field
             */
            this.type = this.options.def.type;

            if (this.model && this.model.fields) {
                // Set module field definition (vardef)
                var clonedVarDef = _.clone(this.model.fields[this.name]);
                /**
                 * Field metadata definition (vardef + viewdef).
                 *
                 * Viewdef are copied over vardef.
                 * @property {Object}
                 * @member View.Field
                 */
                // Beware of shallow clone! We assume here that vardef object has only primitive types
                this.def = clonedVarDef ? _.extend(clonedVarDef, options.def) : options.def;
            }
            else {
                this.def = this.options.def;
            }

            /**
             * i18n-ed field label.
             * @property {String}
             * @member View.Field
             */
            this.label = app.lang.get(this.def.label || this.def.vname || this.name, this.module);

            /**
             * Compiled template.
             * @property {Function}
             * @member View.Field
             */
            this.template = app.template.empty;

            // Bind validation error event
            // Note we bind it regardless of which view we on (only need for edit type views)
            if (this.model) {
                this.model.on("error:validation:" + this.name, this.handleValidationError, this);
            }
        },

        /**
         * Loads template for this field.
         * @private
         */
        _loadTemplate: function() {
            var viewFallbackMap = {
                'edit': 'detail'
            };

            // options.viewName or view metadata type is used to override the template
            var viewName = this.options.viewName ||
                (this.view.meta && this.view.meta.type ? this.view.meta.type : this.view.name);
            while (viewName) {
                if (app.acl.hasAccessToModel(viewName, this.model, this.name)) break;
                viewName = viewFallbackMap[viewName];
            }

            if (viewName) {
                var fallbackFieldTemplate = this.view.fallbackFieldTemplate || "default";
                this.template = app.template.getField(this.type, viewName, fallbackFieldTemplate) ||
                                // Fallback to text field if template is not defined for this type
                                app.template.getField("text", viewName, fallbackFieldTemplate) ||
                                // Safeguard with an empty template
                                app.template.empty;
           }
        },

        /**
         * Override default Backbone.Events to also use custom handlers.
         *
         * The events hash is similar to Backbone.View events hash. The framework stores the event handlers as
         * part of the field instance with the `"callback_"` prefix.
         * <pre><code>
         * events: {
         *     handler: "function() {}";
         * }
         * </code></pre>
         * The above handler is stored as (`"this"` points to the instance of the `Field` class):
         * <pre><code>
         * this.callback_handler
         * </code></pre>
         * @private
         * @param {Object} events Hash of events and their handlers
         */
        delegateEvents: function(events) {
            // We may have:
            // this.events -- comes from custom .js controllers
            // this.def.events -- comes from metadata. See, for example, buttons section in portal.js file
            events = events || this.events || (this.def ? this.def.events : null);
            if (!events) return;

            events = _.clone(events);

            _.each(events, function(eventHandler, handlerName) {
                var callback = this[eventHandler];

                // If our callbacks / events have not been registered, go ahead and registered.
                if (!callback && _.isString(eventHandler)) {
                    try {
                        callback = eval("[" + eventHandler + "][0]");
                        // Store this callback if it is a function. Prefix it with "callback_"
                        if (_.isFunction(callback)) {
                            this["callback_" + handlerName] = callback;
                            events[handlerName] = "callback_" + handlerName;
                        }
                    } catch (e) {
                        app.logger.error("Failed to set up event callback '" + handlerName +
                            "' in " + this + "; error: " + e +
                            "\n---\n" + eventHandler);
                        delete events[handlerName];
                    }
                }

            }, this);

            Backbone.View.prototype.delegateEvents.call(this, events);
        },

        /**
         * Renders a field widget.
         *
         * This method checks ACLs to choose the correct template.
         * Once the template is rendered, DOM changes are bound to the model.
         * @return {Object} The instance of this field.
         */
        _render: function() {
            this._loadTemplate();
            if (this.model instanceof Backbone.Model) {
                /**
                 * Model property value.
                 * @property {String}
                 * @member View.Field
                 */
                this.value = this.format(this.model.has(this.name) ? this.model.get(this.name) : "");
            }

            this.$el.html(this.template(this));
            this.unbindDom();
            this.bindDomChange();
            return this;
        },

        /**
         * Binds DOM changes to a model.
         *
         * The default implementation of this method binds value changes of {@link View.Field#fieldTag} element
         * to model's `Backbone.Model#set` method. Override this method if you need custom binding.
         */
        bindDomChange: function() {
            if (!(this.model instanceof Backbone.Model)) return;

            var self = this;
            var el = this.$el.find(this.fieldTag);
            el.on("change", function() {
                self.model.set(self.name, self.unformat(el.val()));
            });
        },

        /**
         * Binds model changes to this field.
         *
         * The default implementation makes sure this field gets re-rendered
         * whenever the corresponding model attribute changes.
         */
        bindDataChange: function() {
            if (this.model) {
                this.model.on("change:" + this.name, this.render, this);
            }
        },

        /**
         * Formats a value for display.
         *
         * The default implementation returns `value` without modifying it.
         * Override this method to provide custom formatting in field controller (`[type].js` file).
         * @param {Mixed} value The value to format.
         * @return {Mixed} Formatted value.
         */
        format: function(value) {
            return value;
        },

        /**
         * Unformats a value for storing in a model.
         *
         * The default implementation returns `value` without modifying it.
         * Override this method to provide custom unformatting in field controller (`[type].js` file).
         * @param {Mixed} value The value to unformat.
         * @return {Mixed} Unformatted value.
         */
        unformat: function(value) {
            return value;
        },

        /**
         * Handles validation errors.
         *
         * The default implementation does nothing.
         * Override this method to provide custom display logic.
         * <pre><code>
         * app.view.Field = app.view.Field.extend({
         *     handleValidationError: function(errors) {
         *       // Your custom logic goes here
         *     }
         * });
         * </code></pre>
         *
         * @param {Object} errors hash of validation errors
         */
        handleValidationError: function(errors) {
            // Override this method
        },

        /**
         * Gets HTML placeholder for a field.
         * @return {String} HTML placeholder for the field as Handlebars safe string.
         */
        getPlaceholder: function() {
            return new Handlebars.SafeString('<span sfuuid="' + this.sfId + '"></span>');
        },

        /**
         * Unbinds DOM changes from field's element.
         *
         * This method performs the opposite of what {@link View.Field#bindDomChange} method does.
         * Override this method if you need custom logic.
         */
        unbindDom: function() {
            this.$el.find(this.fieldTag).off();
        },

        /**
         * Disposes a field.
         *
         * Calls {@link View.Field#unbindDom} and {@link View.Component#_dispose} method of the base class.
         * @protected
         */
        _dispose: function() {
            this.unbindDom();
            app.view.Component.prototype._dispose.call(this);
        },

        /**
         * Gets a string representation of this field.
         * @return {String} String representation of this field.
         */
        toString: function() {
            return "field-" + this.name + "-" + this.sfId + "-" +
                app.view.Component.prototype.toString.call(this);
        }

    });

})(SUGAR.App);
